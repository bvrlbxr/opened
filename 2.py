# ! Дописать return!!
# для вывода времени выполнения программы
import time


class Profiler(object):
    def __enter__(self):
        self._startTime = time.time()

    def __exit__(self, type, value, traceback):
        print("Elapsed time: {:.3f} sec".format(time.time() - self._startTime))

# ==для вывода затрачиваемой памяти
# from memory_profiler import memory_usage
# memory_usage()

# МОДУЛЬ ЗАДАЧ №3

#  задача 2

# Напишите программу, которая принимает на вход строку текста и вычисляет количество букв
# (кириллица, латиница в любом регистре),
# цифр и специальных символов. При выводе в первой строке указывается количество букв,
# во второй - количество цифр, в третьей - количество специальных символов.
#
# Формат ввода
#
# **Hello123**
# Формат вывода
#
#
# 5
# 3
# 4

def koli4estvo(s):
    c = 0  # количество буков
    d = 0  # количество цыфор
    sym = 0  # количество символов

   # s = input()
    for i in s:
        if i.isdigit():
            d += 1
        elif i.isalpha():
            c += 1
        else:
            sym += 1
    print(c)
    print(d)
    print(sym)


#  задача 3

# Написать программу для сжатия строки, в которой алгоритм работает следующим образом:
# string = 'xxxxtttсyyaaa' преобразуется в 'x4t3с1y2a3', то есть последовательность одинаковых символов
# строки заменяется на этот символ и количество его повторений в текущей позиции строки.
# Формат ввода
#
# xxxxtttсyyaaa
# Формат вывода
#
# x4t3с1y2a3

def suspend(s):
    # s = input()
    ch = s[0]
    count = 0
    ans = ''
    for i in s:
        if i == ch:
            count += 1
        else:
            ans = ans + ch + str(count)
            #print(ch + str(count))
            ch = i
            count = 1
    print(ans + ch + str(count))



#  задача 4

# Для строки вывести статистику по количеству входящих в нее символов (без учета регистра),
# сортируя по алфавиту. Игнорируйте всё, кроме букв латиницы и кириллицы. Вывод: символ, пробел, количество.
# Приоритет вывода у латиницы, вывод символов в нижнем регистре.
# Формат ввода
#
# Hello 123 ** hello мама
# Формат вывода
# e 2
# h 2
# l 4
# o 2
# а 2
# м 2

def symbstat(k):
    # k = input()
    allets = ''
    count = 0
    d1 = {}
    s = k.lower()

    for j in s:
        if j.isalpha():

            for i in s:
                if i == j:
                    count += 1

            if j not in allets:
                allets = allets + j
                # print(j + ' ' + str(count))
                d1[j] = {count}

            count = 0

    for key, values in sorted(d1.items()):
        for value in values:
            print('{} {}'.format(key, value))



#  задача 5
# Написать программу, которая из исходной строки оставляет только уникальные слова (без учета регистра),
# но в том порядке, в котором они первый раз встретились. Слова разделены пробелом, вывод слов в нижнем регистре.

# Формат ввода#
# Мама мыла раму мыла мама папа привет

# Формат вывода
# мама мыла раму папа привет
def uniwords(s):
    k = s.lower()
    allwords = ''
    for i in k.split(' '):
        if i not in allwords:
            allwords = allwords + i + ' '
    print(allwords)


#  задача 6

# Дана строка текста (кириллица) со словами через пробел. Среди слов найти все пары анаграмм.
# Пары анаграмм вывести в алфавитном порядке, среди пар сортировка тоже по алфавиту.
# Каждая пара выводится в новой строке в нижнем регистре.
#
# Формат ввода
#
# Кот нос ток сон клад рама вход книга вдох
# Формат вывода
#
#
# вдох вход
# кот ток
# нос сон

def anagram(s):
    k = sorted(s.lower().split())
   # k = s.lower().split()
    d1 = {}
    for i in k:
        for j in k:
            if len(j) == len(i) and i != j:
                if sorted(list(i)) == sorted(list(j)) and j and i not in d1:
                    d1[j] = {i}
    for key, values in d1.items():
        for value in values:
            print('{} {}'.format(value, key))


#  задача 7

 # Написать
    # программу
    # для
    # транслитерации
    # фамилии, имени, отчества
    # для
    # загранпаспорта
    # по
    # установленным
    # МВД
    # РФ
    # требованиям:
    #
    # А(а) -> A(a)
    # Ж(ж) -> Zh(zh)
    # Н(н) -> N(n)
    # Ф(ф) -> F(f)
    # Ъ(ъ) -> Ie(ie)
    # Б(б) -> B(b)
    # З(з) -> Z(z)
    # О(о) -> O(o)
    # Х(х) -> Kh(kh)
    # Э(э) -> E(e)
    # В(в) -> V(v)
    # И(и) -> I(i)
    # П(п) -> P(p)
    # Ц(ц) -> Ts(ts)
    # Ю(ю) -> Iu(iu)
    # Г(г) -> G(g)
    # Й(й) -> I(i)
    # Р(р) -> R(r)
    # Ч(ч) -> Ch(ch)
    # Я(я) -> Ia(ia)
    # Д(д) -> D(d)
    # К(к) -> K(k)
    # С(с) -> S(s)
    # Ш(ш) -> Sh(sh)
    # ь     -> не
    # пишется
    # Е(е) -> E(e)
    # Л(л) -> L(l)
    # Т(т) -> T(t)
    # Щ(щ) -> Shch(shch)
    # Ё(ё) -> E(e)
    # М(м) -> M(m)
    # У(у) -> U(u)
    # Ы(ы) -> Y(y)
def translit(s):

    rus = 'а б в г д е ё ж  з и й к л м н о п р с т у ф х  ц  ч  ш  щ    ъ   ы  э  ю  я'
    trs = 'A B V G D E E Zh Z I I K L M N O P R S T U F Kh Ts Ch Sh Shch Ie  Y  E  Iu Ia'
    d = dict(zip(rus.split(), trs.split()))
    fio = ''

    for i in s:
        if i.lower() in d:

            if i.isupper():
                fio = fio + d[i.lower()]
            else:
                fio = fio + d[i.lower()].lower()

        elif i == ' ':
            fio = fio + ' '

        elif i == 'ь':
            fio = fio + ''
    print(fio)


# Задача 8


# Во времена кнопочных телефонов была популярна система ввода символов T9.
# Она использовала список известных слов, чтобы из всех возможных комбинаций
# (каждой цифре соответствует несколько букв) оставить только "настоящие" слова.
# Осуществите фильтрацию по нажатым клавишам заданных слов и оставьте только те слова,
# начало которых может быть набрано предложенной комбинацией цифр. В первой строке вводится список слов,
# во второй сочетание клавиш. Учитывать только кириллицу.

# Формат ввода
#
# кот арбуз слово завтрак кнопка лес Лоб
# 45
# Формат вывода
#
# кот кнопка Лоб
def T9(s1, s2):
    #s1 = str(input())
    #s2 = str(input())
    d = {2: 'абвг', 3: 'дежз', 4: 'ийкл',
         5: 'мноп', 6: 'рсту', 7: 'фхцч',
         8: 'шщъы', 9: 'ьэюя'}
    s = ''
    s1_ed = s1.split()
    flag = ''
    for j in s1_ed:    # цикл по словам
        for i in j[:len(str(s2))].lower():  # цикл по первым буквам - нет смысла проверять все
            for m in str(s2):  # проверка букв слов s1 на принадлежность
                if i in d[int(m)]:
                    flag = flag + m
                    break
        if flag == str(s2):
            s = s + j + ' '
        flag = ''
    print(s)


# Задача 8 Варианты с инета ппц они
# 1 var
def t9_1():
    d = {'2': 'абвг',
         '3': 'дeжз',
         '4': 'ийкл',
         '5': 'мноп',
         '6': 'рсту',
         '7': 'фхцч',
         '8': 'шщъы',
         '9': 'ьэюя',
         '1': '.,-'}
    a = input().split()
    comb = input()
    for word in a:
        if len(word) >= len(comb) and \
                all(w.lower() in d[c] for w, c in zip(word, comb)):
            print(word, end=' ')

# 2 var
def t9_2():
    d = {'2': {'а', 'б', 'в', 'г'},
         '3': {'д', 'e', 'ж', 'з'},
         '4': {'и', 'й', 'к', 'л'},
         '5': {'м', 'н', 'о', 'п'},
         '6': {'р', 'с', 'т', 'у'},
         '7': {'ф', 'х', 'ц', 'ч'},
         '8': {'ш', 'щ', 'ъ', 'ы'},
         '9': {'ь', 'э', 'ю', 'я'},
         '1': {'.', ',' '-'}}
    a = input().split()
    comb = input()
    for x in a:
        if len(x) >= len(comb) and \
                all([x[i].lower() in d[c] for i, c in enumerate(comb)]):
            print(x, end=' ')

with Profiler() as p:
  t9_1()